---
title: Linux文本流
date: 2019-03-26 09:36:07
description: 🏗️本文解释了文本、流、文本流、标准输入、标准输出、标准错误与重新定向、管道 (pipe)等概念。<br /><br />托瓦兹对<b>“万物皆文件”</b>的说法作出过纠正，改为<b>“万物皆文本流”💧（Everything is a stream of bytes）</b>。系统运行时，数据并不是在一个文件里定居。数据会在CPU的指挥下不断地流动，就好像一个勤劳的上班族。有时数据需要到办公室上班，因此被读入到内存，有时会去酒店休假，传送到外部设备。有的时候，数据需要搬个家，转移到另一个文件。在这样跑来跑去的过程中，数据像是排着队走路的人流，我们叫它<b>文本流（text stream</b>，或者byte stream）。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。🛶为此，Unix定义了<b>流 (stream)</b>，作为连接操作系统各处的<b>公路</b>标准。有了“流”，无论是从内存到外设，还是从内存到文件，所有的数据公路都是相同的格式。至于公路下面是石头还是土地，就都交给操作系统处理，不劳用户操心。<br /><br />理解了以上的概念之后，<b>管道</b>的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用 <code>|</code> 表示管道。
tags: [linux,vim]
---

## 文本流

在计算机中，所谓的数据就是*0*或1的二进制序列，但严格来说，Unix以**字节**（byte）来作为数据的单位，也就是说这个序列每八位（bit）为一个单位。八位的二进制数字，会落在十进制从0到255的范围内。利用ASCII编码，可以把这一个字节转换成为256个字符中的一个。所以，在Unix中，数据完全可以用字符的形式表示出来，也就是所谓的文本（text）。

实际上，如果以位为单位的话，机器会更容易读懂和传输。但Unix系统坚持用字节为单位来表示数据。原因在于，相对于以位为单位的二进制数据，以字节为单位文本直接就人类可读（human readable）。这样的话，无论是计算机配置信息，还是别人写的一首诗，用户都可以直接读懂。当然，并不是所有的数据都是设计来让人读懂的。很多编译好的可执行文件中包含的内容，只有机器能读懂。打开这个文件，尽管也能看到一个个字符，但这些字符并不能组成什么有意义的文本。但Unix系统不会给这种“读不懂”的文件开后门。所有文件都是统一的形式，就能以相同的方法存储，也能共用一套处理工具，从而减少程序开发的难度。

存储文本的文件，就相当于一个个存储数据的房子。在Unix的设计哲学中，一向有“万物皆文件”（Everything is a file）的说法。大部分的文件都对应了存储设备，也就是树莓派的SD卡上的信息。就连表示文件位置的目录，也是一种文件。此外，程序的配置信息，也都存储在文件中。对于Unix系统来说，文件可以广义的认为是可以提供或接收数据的对象。既然这样，Unix系统干脆把提供或接收数据的硬件也表示成文件。这其中，既有外部连接的USB设备，也包括树莓派内部的内存等硬件。在/dev目录下，就可以找到很多这样代表硬件的文件。

但托瓦兹对“万物皆文件”的说法作出过纠正，改为“万物皆文本流”（[Everything is a stream of bytes](http://yarchive.net/comp/linux/everything_is_file.html)）。系统运行时，数据并不是在一个文件里定居。数据会在CPU的指挥下不断地流动，就好像一个勤劳的上班族。有时数据需要到办公室上班，因此被读入到内存，有时会去酒店休假，传送到外部设备。有的时候，数据需要搬个家，转移到另一个文件。在这样跑来跑去的过程中，数据像是排着队走路的人流，我们叫它**文本流（text stream**，或者byte stream）。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Unix定义了**流 (stream)**，作为连接操作系统各处的**公路**标准。有了“流”，无论是从内存到外设，还是从内存到文件，所有的数据公路都是相同的格式。至于公路下面是石头还是土地，就都交给操作系统处理，不劳用户操心。

(说句题外话，如果看过骇客帝国的话，一定会对文本流印象深刻。)

![骇客帝国](2012091402482228.jpg)

## 标准输入，标准输出，标准错误与重新定向

当Unix执行一个程序的时候，会自动打开三个流，**标准输入**(standard input)，**标准输出**(standard output)，**标准错误**(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但它会根据需要使用，并不是一定要使用。

想象一下敲击一个

```shell
$ls
```

键盘敲击的文本流("ls\n"，\n是回车时输入的字符，表示换行)命令行 (命令行实际上也是一个程序)。命令行随后调用/bin/ls得到结果("a.txt")，最后这个输出的文本流("a.txt")流到屏幕，显示出来，比如说：

```shell
a.txt
```

假设说我们不想让文本流流到屏幕，而是流到另一个文件，我们可以采用**重新定向**(redirect)的机制。

```shell
$ls > a.txt
```

**重新定向标准输出**。这里的`>`就是提醒命令行，让它知道我现在想变换文本流的方向了，我们不让标准输出输出到屏幕，而是要到a.txt这个文件 (好像火车轨道换轨)。此时，计算机会新建一个a.txt的文件，并将命令行的标准输出指向这个文件。

有另一个符号:

```shell
$ls >> a.txt
```

这里`>>`的作用也是**重新定向标准输出**。如果`a.txt`已经存在的话，`ls`产生的文本流会附加在`a.txt`的结尾，而不会像`>`那样每次都新建`a.txt`。

我们下面介绍**命令echo**：

```shell
$echo IamVamei
```

`echo` 的作用是**将文本流导向标准输出**。在这里，echo的作用就是将IamVamei输出到屏幕上。如果是

```shell
$echo IamVamei > a.txt
```

a.txt中就会有IamVamei这个文本。

我们也可以用`<`符号来**改变标准输入**。比如`cat`命令，它可以**从标准输入读入文本流，并输出到标准输出**:

```shell
$cat < a.txt
```

我们将cat标准输入指向a.txt，文本会从文件流到cat，然后再输出到屏幕上。当然，我们还可以同时重新定向标准输出:

```shell
$cat < a.txt > b.txt
```

这样，a.txt的内容就复制到了b.txt中。

我们还可以使用`>&`来同时重新定向标准输出和标准错误。假设我们并没有一个目录void。那么

```shell
$cd void > a.txt
```

会在屏幕上返回错误信息。因为此时标准错误依然指向屏幕。当我们使用:

```shell
$cd void >& a.txt
```

错误信息被导向a.txt。

如果只想重新定向标准错误，可以使用`2>`:

```shell
$cd void 2> a.txt > b.txt
```

标准错误对应的总是**2号**，所以有以上写法。标准错误输出到a.txt，标准输出输出到b.txt。

## 管道 (pipe)

理解了以上的内容之后，**管道**的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用`|`表示管道：

```shell
$cat < a.txt | wc
```

`wc`命令代表**word count**，用于**统计**文本中的**行**、**词**以及**字符**的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。

Linux的各个命令实际上高度专业化，并尽量相互独立。每一个都只专注于一个小的功能。但通过pipe，我们可以将这些功能合在一起，实现一些复杂的目的。

## 总结

文本流，标准输入，标准输出，标准错误

```shell
cat, echo, wc

>, >>, <, |
```

---
reference:
[http://www.cnblogs.com/vamei/archive/2012/09/14/2683756.html](http://www.cnblogs.com/vamei/archive/2012/09/14/2683756.html)
